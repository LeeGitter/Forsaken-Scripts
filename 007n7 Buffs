local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character, humanoid, hrp, animator
local prepTrack, dashTrack, endTrack

local PREP_ANIM_ID = 98456918873918
local DASH_ANIM_ID = 106776364623742
local END_ANIM_ID = 18885940850

local DASH_DISTANCE = 60
local PREP_DURATION = 0.55
local DASH_DURATION = 0.5

local ASCEND_AMPLITUDE = 1
local ASCEND_FREQUENCY = 4

local function setupCharacter()
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    hrp = character:WaitForChild("HumanoidRootPart")

    animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end

    local function loadAnimation(id)
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. id
        return animator:LoadAnimation(anim)
    end

    prepTrack = loadAnimation(PREP_ANIM_ID)
    dashTrack = loadAnimation(DASH_ANIM_ID)
    endTrack = loadAnimation(END_ANIM_ID)
end

setupCharacter()
player.CharacterAdded:Connect(setupCharacter)

local function easeOutCubic(t)
    return 1 - (1 - t)^3
end

local dashActive = false

local function playEndAnimation()
    if endTrack then
        endTrack:Play()
    end
end

local function dashSequence()
    if not hrp or not humanoid then return end
    if dashActive then return end
    if prepTrack.IsPlaying or dashTrack.IsPlaying then return end

    dashActive = true

    prepTrack:Play()
    task.wait(PREP_DURATION)
    prepTrack:Stop()

    dashTrack:Play()

    local startCFrame = hrp.CFrame
    local forwardVector = startCFrame.LookVector
    local elapsed = 0
    local lastPosition = hrp.Position

    local connection
    connection = RunService.Heartbeat:Connect(function(dt)
        elapsed = elapsed + dt
        if elapsed > DASH_DURATION then
            dashTrack:Stop()
            connection:Disconnect()
            playEndAnimation()
            dashActive = false
            return
        end

        local progress = elapsed / DASH_DURATION
        local easedProgress = easeOutCubic(progress)

        local targetPosition = startCFrame.Position + forwardVector * DASH_DISTANCE * easedProgress
        local verticalOffset = math.sin(elapsed / DASH_DURATION * math.pi * ASCEND_FREQUENCY) * ASCEND_AMPLITUDE * (1 - progress)
        local newPosition = Vector3.new(targetPosition.X, startCFrame.Y + verticalOffset, targetPosition.Z)

        -- Collision check
        local direction = newPosition - lastPosition
        local dist = direction.Magnitude
        if dist > 0 then
            local raycastParams = RaycastParams.new()
            raycastParams.FilterDescendantsInstances = {character}
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            local rayResult = workspace:Raycast(lastPosition, direction.Unit * dist, raycastParams)

            if rayResult and rayResult.Instance and rayResult.Instance.CanCollide then
                dashTrack:Stop()
                connection:Disconnect()
                playEndAnimation()
                dashActive = false
                return
            end
        end

        hrp.CFrame = CFrame.new(newPosition, newPosition + forwardVector)
        lastPosition = newPosition
    end)
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.Q then
        dashSequence()
    end
end)
